You are an expert in TypeScript, Node.js, Next.js App Router, React, Shadcn UI, Radix UI and Tailwind.

Key Principles
- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported component, subcomponents, helpers, static content, types.

Project Structure
- The main application is in the `packages/app` directory which is a Next.js App Router. Put all frontend-only code in this directory.
- Put all backend logic into one of the `packages` directories:
  - `packages/ai` contains all AI-related code
  - `packages/api` contains all API routes
  - `packages/auth` contains the config for better-auth and helper functions
  - `packages/database` contains the database schema and auto-generated types
  - `packages/i18n` contains translations and internationalization helper functions
  - `packages/logs` contains the logging config and helper functions
  - `packages/mail` contains providers for sending mails and email templates
  - `packages/payments` contains code for payment providers and payment processing
  - `packages/storage` contains providers for storing files and images
  - `packages/utils` contains utility functions

Naming Conventions
- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for components.

TypeScript Usage
- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use maps instead.
- Use functional components with TypeScript interfaces.

Syntax and Formatting
- Use the "function" keyword for pure functions.
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.
- Use declarative JSX.

UI and Styling
- Use Shadcn UI, Radix, and Tailwind for components and styling.
- Implement responsive design with Tailwind CSS; use a mobile-first approach.
- Use the `cn` function for class name concatenation.

Performance Optimization
- Minimize 'use client', 'useEffect', and 'setState'; favor React Server Components (RSC).
- Wrap client components in Suspense with fallback.
- Use dynamic loading for non-critical components.
- Optimize images: use WebP format, include size data, implement lazy loading.

Key Conventions
- Use 'nuqs' for URL search parameter state management.
- Optimize Web Vitals (LCP, CLS, FID).
- Limit 'use client':
- Favor server components and Next.js SSR.
- Use only for Web API access in small components.
- Avoid for data fetching or state management.

Follow Next.js docs for Data Fetching, Rendering, and Routing.
Follow the documentation at supastarter.dev/docs/nextjs for supastarter specifc patterns.

引用的位置為：
import { cn } from "@ui/lib";

我的.env在根目錄下
## Button 組件使用規則

### 支援的 Button variant 選項
Button 組件只支援以下 variant 值，請勿使用其他變體名稱：

**可用的 variant 選項：**
- `primary` - 主要按鈕（預設藍色，用於主要操作）
- `error` - 錯誤/危險按鈕（紅色，用於刪除等危險操作）
- `outline` - 輪廓按鈕（透明背景有邊框）
- `secondary` - 次要按鈕（灰色，預設選項）
- `light` - 淺色按鈕（淺灰色背景）
- `ghost` - 幽靈按鈕（透明背景，hover 時顯示）
- `link` - 連結樣式按鈕（下劃線樣式）

**支援的 size 選項：**
- `sm` - 小尺寸按鈕
- `md` - 中等尺寸按鈕（預設）
- `lg` - 大尺寸按鈕
- `icon` - 圖示按鈕（正方形）

### 常見錯誤用法 ❌
**絕對不要使用以下錯誤的 variant 名稱：**
- ❌ `variant="destructive"` - 這不存在，應該使用 `variant="error"`
- ❌ `variant="danger"` - 這不存在，應該使用 `variant="error"`
- ❌ `variant="delete"` - 這不存在，應該使用 `variant="error"`
- ❌ `variant="warning"` - 這不存在，請根據用途選擇合適的 variant
- ❌ `variant="success"` - 這不存在，使用 `variant="primary"` 或 `variant="secondary"`

### 正確用法範例 ✅

```tsx
// 刪除按鈕 - 使用 error variant
<Button variant="error" onClick={handleDelete}>
  刪除
</Button>

// 主要操作按鈕
<Button variant="primary" type="submit">
  提交
</Button>

// 取消按鈕
<Button variant="outline" onClick={onCancel}>
  取消
</Button>

// 次要操作按鈕
<Button variant="secondary">
  查看詳情
</Button>

// 連結樣式按鈕
<Button variant="link" onClick={onNavigate}>
  了解更多
</Button>
```

### TypeScript 錯誤排除
如果遇到 Button variant 相關的 TypeScript 錯誤：
1. 檢查 variant 值是否在上述支援清單中
2. 危險操作（刪除、重設等）統一使用 `variant="error"`
3. 如果需要其他樣式，考慮使用 `className` 進行客製化或聯繫團隊討論擴展 variant 選項

### 按鈕語意化使用建議
- **刪除、重設、清空等危險操作**：使用 `variant="error"`
- **主要提交、確認操作**：使用 `variant="primary"`
- **取消、關閉操作**：使用 `variant="outline"`
- **一般操作**：使用 `variant="secondary"`（預設）
- **導航連結**：使用 `variant="link"`

## 完整 CRUD 表格實現流程

### 概述
以 `/expenses` 模組為參考，建立一個完整的 CRUD 表格功能需要以下步驟。這個流程涵蓋從資料庫設計到前端 UI 的完整實現。

### 1. 資料庫層 (packages/database)

#### 1.1 Prisma Schema 定義
在 `packages/database/prisma/schema.prisma` 中定義模型：

```prisma
model YourModel {
  id             String       @id @default(cuid())
  field1         String       // 必填欄位
  field2         Decimal      @db.Decimal(15, 2) // 數值欄位
  field3         String?      // 可選欄位
  field4         DateTime     @default(now())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@map("your_table_name")
}
```

#### 1.2 資料庫查詢函數
在 `packages/database/prisma/queries/your-model.ts` 中實現 CRUD 操作：

```typescript
import { db } from "../client";

export interface CreateYourModelData {
  field1: string;
  field2: number;
  field3?: string;
  organizationId: string;
}

export interface UpdateYourModelData {
  field1?: string;
  field2?: number;
  field3?: string;
}

export async function createYourModel(data: CreateYourModelData) {
  return await db.yourModel.create({ data });
}

export async function getYourModelsByOrganizationId(organizationId: string) {
  return await db.yourModel.findMany({
    where: { organizationId },
    orderBy: { createdAt: "desc" },
  });
}

export async function updateYourModel(id: string, data: UpdateYourModelData) {
  return await db.yourModel.update({
    where: { id },
    data,
  });
}

export async function deleteYourModel(id: string) {
  return await db.yourModel.delete({ where: { id } });
}
```

### 2. API 層 (packages/api)

#### 2.1 API 路由實現
在 `packages/api/src/routes/organizations/your-model.ts` 中實現 RESTful API：

```typescript
import { Hono } from "hono";
import { describeRoute } from "hono-openapi";
import { resolver, validator } from "hono-openapi/zod";
import { z } from "zod";
import { authMiddleware } from "../../middleware/auth";
import { verifyOrganizationMembership } from "./lib/membership";
import {
  createYourModel,
  deleteYourModel,
  getYourModelsByOrganizationId,
  updateYourModel,
} from "@repo/database";

const CreateSchema = z.object({
  field1: z.string().min(1, "field1 是必填的"),
  field2: z.number().min(0, "field2 不能為負數"),
  field3: z.string().optional(),
});

const UpdateSchema = CreateSchema.partial();

export const yourModelsRouter = new Hono()
  .use(authMiddleware)
  .get("/your-models", 
    validator("query", z.object({ organizationId: z.string() })),
    async (c) => {
      const { organizationId } = c.req.valid("query");
      const user = c.get("user");
      
      await verifyOrganizationMembership(organizationId, user.id);
      
      const data = await getYourModelsByOrganizationId(organizationId);
      return c.json({ data });
    }
  )
  .post("/your-models",
    validator("json", CreateSchema.extend({ organizationId: z.string() })),
    async (c) => {
      const data = c.req.valid("json");
      const user = c.get("user");
      
      await verifyOrganizationMembership(data.organizationId, user.id);
      
      const result = await createYourModel(data);
      return c.json({ data: result }, 201);
    }
  )
  .put("/your-models/:id",
    validator("param", z.object({ id: z.string() })),
    validator("json", UpdateSchema),
    async (c) => {
      const { id } = c.req.valid("param");
      const data = c.req.valid("json");
      const user = c.get("user");
      
      const result = await updateYourModel(id, data);
      await verifyOrganizationMembership(result.organizationId, user.id);
      
      return c.json({ data: result });
    }
  )
  .delete("/your-models/:id",
    validator("param", z.object({ id: z.string() })),
    async (c) => {
      const { id } = c.req.valid("param");
      const user = c.get("user");
      
      const result = await deleteYourModel(id);
      await verifyOrganizationMembership(result.organizationId, user.id);
      
      return c.json({ message: "記錄已成功刪除" });
    }
  );
```

#### 2.2 路由註冊
在 `packages/api/src/routes/organizations/router.ts` 中註冊路由：

```typescript
import { yourModelsRouter } from "./your-model";

export const organizationsRouter = new Hono()
  .basePath("/organizations")
  .route("/", yourModelsRouter)
  // ... 其他路由
```

### 3. 前端實現 (apps/web)

#### 3.1 資料型別定義
在 `apps/web/app/(saas)/app/(organizations)/[organizationSlug]/your-models/components/columns.tsx` 中定義：

```typescript
export interface YourModelRecord {
  id: string;
  field1: string;
  field2: number;
  field3?: string | null;
  organizationId: string;
  createdAt: Date;
  updatedAt: Date;
}
```

#### 3.2 表格欄位配置
在同一檔案中實現 columns：

```typescript
import { DataTableColumnHeader } from "@saas/shared/components/DataTable/DataTableColumnHeader";
import type { ColumnDef } from "@tanstack/react-table";
import { Button } from "@ui/components/button";
import { Edit2 } from "lucide-react";

export function createColumns(
  onEdit: (record: YourModelRecord) => void,
): ColumnDef<YourModelRecord>[] {
  return [
    {
      accessorKey: "field1",
      header: ({ column }) => (
        <DataTableColumnHeader column={column} title="欄位1" />
      ),
    },
    {
      accessorKey: "field2",
      header: ({ column }) => (
        <DataTableColumnHeader column={column} title="欄位2" />
      ),
      cell: ({ row }) => {
        const value = row.getValue("field2") as number;
        return value.toLocaleString();
      },
    },
    {
      id: "actions",
      header: "操作",
      cell: ({ row }) => {
        const record = row.original;
        return (
          <Button variant="ghost" size="sm" onClick={() => onEdit(record)}>
            <Edit2 className="size-4" />
          </Button>
        );
      },
    },
  ];
}
```

#### 3.3 新增對話框
創建 `create-your-model-dialog.tsx`：

```typescript
"use client";

import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "@ui/components/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@ui/components/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@ui/components/form";
import { Input } from "@ui/components/input";
import { Plus } from "lucide-react";
import { useState } from "react";
import { useForm } from "react-hook-form";
import { z } from "zod";

const createSchema = z.object({
  field1: z.string().min(1, "field1 是必填的"),
  field2: z.number().min(0, "field2 不能為負數"),
  field3: z.string().optional(),
});

type CreateFormData = z.infer<typeof createSchema>;

interface CreateDialogProps {
  organizationId: string;
  onSuccess?: () => void;
}

export function CreateYourModelDialog({
  organizationId,
  onSuccess,
}: CreateDialogProps) {
  const [open, setOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const form = useForm<CreateFormData>({
    resolver: zodResolver(createSchema),
    defaultValues: {
      field2: 0,
    },
  });

  const onSubmit = async (data: CreateFormData) => {
    setIsLoading(true);
    try {
      const response = await fetch("/api/organizations/your-models", {
        method: "POST",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ...data, organizationId }),
      });

      if (!response.ok) {
        throw new Error("新增失敗");
      }

      form.reset();
      setOpen(false);
      onSuccess?.();
    } catch (error) {
      console.error("新增失敗:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button>
          <Plus className="mr-2 size-4" />
          新增記錄
        </Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>新增記錄</DialogTitle>
          <DialogDescription>填寫下方資訊來新增記錄。</DialogDescription>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)}>
            <div className="grid gap-4 py-4">
              <FormField
                control={form.control}
                name="field1"
                render={({ field }) => (
                  <FormItem className="grid grid-cols-4 items-center gap-4">
                    <FormLabel className="text-right">欄位1 *</FormLabel>
                    <div className="col-span-3">
                      <FormControl>
                        <Input placeholder="輸入欄位1" {...field} />
                      </FormControl>
                      <FormMessage />
                    </div>
                  </FormItem>
                )}
              />
              {/* 其他欄位 */}
            </div>
            <DialogFooter>
              <Button type="button" variant="outline" onClick={() => setOpen(false)}>
                取消
              </Button>
              <Button type="submit" disabled={isLoading}>
                {isLoading ? "新增中..." : "新增"}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}
```

#### 3.4 編輯對話框
創建 `edit-your-model-dialog.tsx`（結構類似新增對話框，但支援編輯和刪除）。

**編輯對話框按鈕佈局規則：**
- 刪除按鈕必須放在 DialogFooter 的最左邊
- 使用 `variant="error"` 為刪除按鈕
- 取消和確認按鈕放在右邊，使用 flex gap 分組
- 必須使用 `!justify-between` 來強制覆蓋預設的 justify-end 樣式

```tsx
<DialogFooter className="!justify-between">
  <Button
    type="button"
    variant="error"
    onClick={handleDelete}
    disabled={isDeleting}
  >
    <Trash2 className="mr-2 size-4" />
    {isDeleting ? "刪除中..." : "刪除"}
  </Button>
  <div className="flex gap-2">
    <Button
      type="button"
      variant="outline"
      onClick={() => onOpenChange(false)}
    >
      取消
    </Button>
    <Button type="submit" disabled={isLoading}>
      {isLoading ? "更新中..." : "更新"}
    </Button>
  </div>
</DialogFooter>
```

#### 3.5 主頁面實現
創建 `page.tsx`：

```typescript
"use client";

import { useActiveOrganization } from "@saas/organizations/hooks/use-active-organization";
import { DataTable } from "@saas/shared/components/DataTable";
import { PageHeader } from "@saas/shared/components/PageHeader";
import { useEffect, useState } from "react";
import type { YourModelRecord } from "./components/columns";
import { createColumns } from "./components/columns";
import { CreateYourModelDialog } from "./components/create-your-model-dialog";
import { EditYourModelDialog } from "./components/edit-your-model-dialog";

export default function YourModelsPage() {
  const { activeOrganization, loaded } = useActiveOrganization();
  const [data, setData] = useState<YourModelRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [editingRecord, setEditingRecord] = useState<YourModelRecord | null>(null);
  const [editDialogOpen, setEditDialogOpen] = useState(false);

  const fetchData = async () => {
    if (!activeOrganization?.id) return;

    setIsLoading(true);
    try {
      const response = await fetch(
        `/api/organizations/your-models?organizationId=${activeOrganization.id}`,
        {
          method: "GET",
          credentials: "include",
          headers: { "Content-Type": "application/json" },
        },
      );

      if (response.ok) {
        const result = await response.json();
        setData(result.data || []);
      }
    } catch (error) {
      console.error("獲取數據失敗:", error);
      setData([]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleEdit = (record: YourModelRecord) => {
    setEditingRecord(record);
    setEditDialogOpen(true);
  };

  const handleEditSuccess = () => {
    fetchData();
    setEditingRecord(null);
  };

  const columns = createColumns(handleEdit);

  useEffect(() => {
    if (activeOrganization?.id && loaded) {
      fetchData();
    }
  }, [activeOrganization?.id, loaded]);

  if (!loaded) {
    return <div className="container py-6">載入中...</div>;
  }

  return (
    <div className="container space-y-8 py-6">
      <PageHeader
        title="記錄列表"
        subtitle="管理所有記錄"
        actions={
          activeOrganization && (
            <CreateYourModelDialog
              organizationId={activeOrganization.id}
              onSuccess={fetchData}
            />
          )
        }
      />

      <DataTable
        columns={columns}
        data={data}
        isLoading={isLoading}
        searchKey="field1"
        searchPlaceholder="搜尋記錄"
      />

      {editingRecord && (
        <EditYourModelDialog
          record={editingRecord}
          open={editDialogOpen}
          onOpenChange={setEditDialogOpen}
          onSuccess={handleEditSuccess}
        />
      )}
    </div>
  );
}
```

### 4. 檔案結構檢查清單

實現完整的 CRUD 表格功能需要創建以下檔案：

#### 後端檔案:
- `packages/database/prisma/schema.prisma` - 資料庫模型定義
- `packages/database/prisma/queries/your-model.ts` - 資料庫查詢函數
- `packages/api/src/routes/organizations/your-model.ts` - API 路由實現
- 更新 `packages/api/src/routes/organizations/router.ts` - 路由註冊

#### 前端檔案:
- `apps/web/app/(saas)/app/(organizations)/[organizationSlug]/your-models/page.tsx` - 主頁面
- `apps/web/app/(saas)/app/(organizations)/[organizationSlug]/your-models/components/columns.tsx` - 表格欄位定義
- `apps/web/app/(saas)/app/(organizations)/[organizationSlug]/your-models/components/create-your-model-dialog.tsx` - 新增對話框
- `apps/web/app/(saas)/app/(organizations)/[organizationSlug]/your-models/components/edit-your-model-dialog.tsx` - 編輯對話框

### 5. 重要注意事項

1. **權限驗證**: 所有 API 都必須驗證用戶是否為組織成員
2. **表單驗證**: 前端和後端都要進行 Zod 驗證
3. **錯誤處理**: 適當的錯誤處理和用戶反饋
4. **載入狀態**: 提供適當的載入指示器
5. **資料重新整理**: 操作成功後重新獲取資料
6. **型別安全**: 確保前後端型別一致性
7. **響應式設計**: 使用 Tailwind 進行響應式佈局

### 6. 常用模式

- 使用 `useActiveOrganization` 獲取當前組織
- 使用 `DataTable` 組件顯示表格
- 使用 `PageHeader` 組件顯示頁面標題和操作按鈕
- 使用 `Dialog` 組件實現彈出式表單
- 使用 `react-hook-form` + `zod` 進行表單驗證
- 使用 `useState` 管理組件狀態
- 使用 `useEffect` 處理資料獲取

## 表單組件正確使用規則

### React Hook Form + Shadcn UI Form 組件配置

**❌ 錯誤的表單配置（會導致 input 無法輸入）：**

```typescript
// 錯誤：直接使用 register 而不是 Form 組件
const { register, handleSubmit, formState: { errors } } = useForm();

return (
  <form onSubmit={handleSubmit(onSubmit)}>
    <Label htmlFor="name">姓名</Label>
    <Input {...register("name")} />
    {errors.name && <p>{errors.name.message}</p>}
  </form>
);
```

**✅ 正確的表單配置：**

```typescript
// 正確：使用 Form 組件包裝，搭配 FormField
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@ui/components/form";

const form = useForm<FormData>({
  resolver: zodResolver(schema),
  defaultValues: {
    name: "",
  },
});

return (
  <Form {...form}>
    <form onSubmit={form.handleSubmit(onSubmit)}>
      <FormField
        control={form.control}
        name="name"
        render={({ field }) => (
          <FormItem>
            <FormLabel>姓名</FormLabel>
            <FormControl>
              <Input placeholder="輸入姓名" {...field} />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />
    </form>
  </Form>
);
```

### 關鍵點說明

1. **必須使用 Form 組件**：所有使用 react-hook-form 的表單都必須用 `<Form {...form}>` 包裝
2. **使用 FormField 代替 register**：每個欄位都要用 `FormField` 配合 `render` prop
3. **FormControl 包裝 Input**：Input 組件必須被 `FormControl` 包裝
4. **使用 FormMessage 顯示錯誤**：用 `FormMessage` 取代手動顯示錯誤訊息
5. **form.control 傳遞給 FormField**：確保 `control={form.control}` 正確傳遞

### Select 組件的正確配置

```typescript
<FormField
  control={form.control}
  name="category"
  render={({ field }) => (
    <FormItem>
      <FormLabel>類別</FormLabel>
      <Select onValueChange={field.onChange} defaultValue={field.value}>
        <FormControl>
          <SelectTrigger>
            <SelectValue placeholder="選擇類別" />
          </SelectTrigger>
        </FormControl>
        <SelectContent>
          <SelectItem value="option1">選項1</SelectItem>
          <SelectItem value="option2">選項2</SelectItem>
        </SelectContent>
      </Select>
      <FormMessage />
    </FormItem>
  )}
/>
```

### 數字欄位的正確處理

```typescript
<FormField
  control={form.control}
  name="price"
  render={({ field }) => (
    <FormItem>
      <FormLabel>價格</FormLabel>
      <FormControl>
        <Input
          type="number"
          step="1"
          placeholder="輸入價格"
          {...field}
          onChange={(e) => {
            const value = e.target.value;
            field.onChange(value === "" ? undefined : Number(value));
          }}
          value={field.value || ""}
        />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

### 表單重置和預設值

```typescript
// 新增表單：明確設定預設值
const form = useForm<FormData>({
  resolver: zodResolver(schema),
  defaultValues: {
    name: "",
    category: "default",
    price: undefined,
  },
});

// 編輯表單：使用 useEffect 重置表單
useEffect(() => {
  if (editData) {
    form.reset({
      name: editData.name,
      category: editData.category,
      price: editData.price || undefined,
    });
  }
}, [editData, form]);
```

### 檢查清單

創建任何表單對話框時，確保：

1. ✅ 導入 Form 相關組件：`Form`, `FormControl`, `FormField`, `FormItem`, `FormLabel`, `FormMessage`
2. ✅ 使用 `const form = useForm()` 而非解構賦值
3. ✅ 用 `<Form {...form}>` 包裝整個表單
4. ✅ 每個欄位都使用 `FormField` 和 `render` prop
5. ✅ Input 組件被 `FormControl` 包裝
6. ✅ 使用 `FormMessage` 顯示錯誤
7. ✅ 數字欄位正確處理 `onChange` 和 `value`
8. ✅ Select 組件正確配置 `onValueChange` 和 `defaultValue`

### 常見錯誤及解決方案

| 問題 | 原因 | 解決方案 |
|------|------|----------|
| Input 無法輸入 | 未使用 Form 組件包裝 | 用 `<Form {...form}>` 包裝表單 |
| 錯誤訊息不顯示 | 使用手動錯誤處理 | 改用 `FormMessage` 組件 |
| Select 無法選擇 | 未正確配置 FormControl | 用 `FormControl` 包裝 `SelectTrigger` |
| 數字欄位有問題 | 未處理字串轉數字 | 自訂 `onChange` 處理邏輯 |
| 編輯時欄位為空 | 未使用 useEffect 重置 | 在 useEffect 中呼叫 `form.reset()` |

這套表單配置確保了與 Shadcn UI 設計系統的完整整合，並提供最佳的用戶體驗。

## API 錯誤處理和表單欄位視覺回饋規則

### API 回應錯誤處理標準模式

**❌ 錯誤的錯誤處理（會導致 JSON 解析失敗）：**

```typescript
// 錯誤：直接假設回應是 JSON 格式
if (!response.ok) {
  const error = await response.json();
  throw new Error(error.message || "操作失敗");
}
```

**✅ 正確的錯誤處理模式：**

```typescript
// 正確：先讀取為文字，再嘗試解析 JSON
if (!response.ok) {
  let errorMessage = "操作失敗";
  try {
    const responseText = await response.text();
    // 嘗試解析為 JSON
    try {
      const error = JSON.parse(responseText);
      errorMessage = error.message || errorMessage;
    } catch {
      // 如果不是 JSON 格式，使用純文字作為錯誤訊息
      errorMessage = responseText || errorMessage;
    }
  } catch {
    // 如果連讀取文字都失敗了，使用預設錯誤訊息
    errorMessage = "操作失敗";
  }
  
  // 根據錯誤類型設定對應欄位錯誤
  if (errorMessage.includes("代碼已被使用") || errorMessage.includes("代碼重複")) {
    form.setError("code", {
      type: "server",
      message: errorMessage,
    });
    return; // 不拋出錯誤，讓表單繼續顯示
  }
  
  throw new Error(errorMessage);
}
```

### 表單欄位錯誤視覺回饋

**必須使用 `fieldState` 來實現錯誤狀態的視覺回饋：**

```typescript
<FormField
  control={form.control}
  name="code"
  render={({ field, fieldState }) => (
    <FormItem>
      <FormLabel>代碼 *</FormLabel>
      <FormControl>
        <Input
          placeholder="輸入代碼"
          {...field}
          className={fieldState.error ? "border-red-500 focus:border-red-500 focus:ring-red-500" : ""}
        />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

### 常見服務器錯誤的欄位映射

根據錯誤訊息內容，將錯誤設定到對應的表單欄位：

```typescript
// 代碼重複錯誤
if (errorMessage.includes("代碼已被使用") || errorMessage.includes("代碼重複")) {
  form.setError("code", { type: "server", message: errorMessage });
  return;
}

// 名稱重複錯誤
if (errorMessage.includes("名稱已存在") || errorMessage.includes("名稱重複")) {
  form.setError("name", { type: "server", message: errorMessage });
  return;
}

// 電子郵件錯誤
if (errorMessage.includes("電子郵件") || errorMessage.includes("email")) {
  form.setError("email", { type: "server", message: errorMessage });
  return;
}

// 通用錯誤，拋出到 catch 區塊
throw new Error(errorMessage);
```

### 錯誤處理最佳實踐

1. **統一錯誤解析**：所有 API 呼叫都使用相同的錯誤解析邏輯
2. **欄位級錯誤**：特定欄位錯誤直接設定到對應欄位，不要拋出到全域
3. **視覺回饋**：錯誤狀態的欄位必須有紅色邊框等視覺提示
4. **保持表單開啟**：欄位級錯誤時，使用 `return` 而非 `throw`，讓使用者可以修正後重新提交
5. **錯誤訊息一致性**：使用服務器回傳的原始錯誤訊息，保持一致性

### 完整的表單提交錯誤處理範例

```typescript
const onSubmit = async (data: FormData) => {
  setIsLoading(true);
  try {
    const response = await fetch("/api/endpoint", {
      method: "POST",
      credentials: "include",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      let errorMessage = "操作失敗";
      try {
        const responseText = await response.text();
        try {
          const error = JSON.parse(responseText);
          errorMessage = error.message || errorMessage;
        } catch {
          errorMessage = responseText || errorMessage;
        }
      } catch {
        errorMessage = "操作失敗";
      }

      // 根據錯誤類型設定欄位錯誤
      if (errorMessage.includes("代碼已被使用")) {
        form.setError("code", { type: "server", message: errorMessage });
        return;
      }
      
      throw new Error(errorMessage);
    }

    // 成功處理
    form.reset();
    onOpenChange(false);
    onSuccess?.();
  } catch (error) {
    console.error("操作失敗:", error);
    // 這裡可以添加 toast 通知
  } finally {
    setIsLoading(false);
  }
};
```

這套錯誤處理模式確保了一致的用戶體驗和穩定的 API 錯誤處理。

## 資料篩選器組件標準實現

### 概述
以 `/expenses` 模組的 `ExpenseFilters` 組件為標準，所有 CRUD 列表頁面都應該實現一致的篩選器功能和 UI 樣式。

### 1. 篩選器組件結構

#### 1.1 基本組件導入
```typescript
"use client";

import { Badge } from "@ui/components/badge";
import { Button } from "@ui/components/button";
import { Input } from "@ui/components/input";
import { Label } from "@ui/components/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@ui/components/select";
import { Calendar, DollarSign, Filter, Paperclip, X } from "lucide-react";
import { useState } from "react";
```

#### 1.2 篩選器介面定義
```typescript
export interface YourFilters {
  // 根據需求定義篩選條件
  dateFrom?: string;
  dateTo?: string;
  category?: string;
  status?: string;
  search?: string;
  // 其他篩選條件...
}

interface YourFiltersProps {
  data: YourRecord[];
  onFilterChange: (filteredData: YourRecord[]) => void;
  onFiltersChange?: (filters: YourFilters) => void;
}
```

### 2. 篩選器 UI 佈局標準

#### 2.1 頂部控制列
```typescript
{/* 篩選器控制列 */}
<div className="flex items-center justify-between">
  <div className="flex items-center gap-2">
    <Button
      variant="outline"
      size="sm"
      onClick={() => setIsExpanded(!isExpanded)}
      className="gap-2"
    >
      <Filter className="size-4" />
      篩選器{" "}
      {hasActiveFilters &&
        `(${
          Object.values(filters).filter(
            (v) => v !== undefined && v !== null && v !== "" && v !== "all"
          ).length
        })`}
    </Button>
    {hasActiveFilters && (
      <Button variant="ghost" size="sm" onClick={clearFilters}>
        <X className="size-4 mr-1" />
        清除篩選
      </Button>
    )}
  </div>

  {/* 主要搜尋框 */}
  <div className="flex items-center gap-2">
    <Input
      placeholder="搜尋..."
      value={filters.search || ""}
      onChange={(e) => updateFilter("search", e.target.value)}
      className="w-64"
    />
  </div>
</div>
```

#### 2.2 展開式篩選面板
```typescript
{/* 展開的篩選器 */}
{isExpanded && (
  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 p-4 border rounded-lg bg-muted/20">
    {/* 每個篩選條件都包在 div 中，使用 space-y-2 */}
    <div className="space-y-2">
      <Label className="text-sm font-medium">標籤名稱</Label>
      <Select
        value={filters.fieldName || ""}
        onValueChange={(value) =>
          updateFilter("fieldName", value === "all" ? undefined : value)
        }
      >
        <SelectTrigger>
          <SelectValue placeholder="選擇..." />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="all">全部</SelectItem>
          {/* 動態選項 */}
        </SelectContent>
      </Select>
    </div>
    
    {/* 日期範圍的特殊處理 */}
    <div className="space-y-2">
      <Label className="text-sm font-medium flex items-center gap-1">
        <Calendar className="size-4" />
        日期區間
      </Label>
      <div className="space-y-2">
        <Input
          type="date"
          placeholder="開始日期"
          value={filters.dateFrom || ""}
          onChange={(e) => updateFilter("dateFrom", e.target.value)}
        />
        <Input
          type="date"
          placeholder="結束日期"
          value={filters.dateTo || ""}
          onChange={(e) => updateFilter("dateTo", e.target.value)}
        />
      </div>
    </div>
    
    {/* 數字範圍的特殊處理 */}
    <div className="space-y-2">
      <Label className="text-sm font-medium flex items-center gap-1">
        <DollarSign className="size-4" />
        金額範圍
      </Label>
      <div className="space-y-2">
        <Input
          type="number"
          placeholder="最小金額"
          value={filters.amountMin || ""}
          onChange={(e) => {
            const value = e.target.value;
            updateFilter("amountMin", value === "" ? undefined : Number(value));
          }}
        />
        <Input
          type="number"
          placeholder="最大金額"
          value={filters.amountMax || ""}
          onChange={(e) => {
            const value = e.target.value;
            updateFilter("amountMax", value === "" ? undefined : Number(value));
          }}
        />
      </div>
    </div>
  </div>
)}
```

### 3. 篩選器標籤顯示

#### 3.1 標籤樣式標準
```typescript
{/* 已選擇的篩選條件標籤 */}
{hasActiveFilters && (
  <div className="flex flex-wrap gap-2">
    {filters.category && (
      <Badge status="info" className="gap-1">
        類別: {filters.category}
        <button
          type="button"
          onClick={() => updateFilter("category", undefined)}
          className="ml-1 hover:bg-destructive/20 rounded-full"
        >
          <X className="size-3" />
        </button>
      </Badge>
    )}
    
    {/* 日期標籤 */}
    {filters.dateFrom && (
      <Badge status="info" className="gap-1">
        開始: {filters.dateFrom}
        <button
          type="button"
          onClick={() => updateFilter("dateFrom", undefined)}
          className="ml-1 hover:bg-destructive/20 rounded-full"
        >
          <X className="size-3" />
        </button>
      </Badge>
    )}
    
    {/* 數字範圍標籤 */}
    {filters.amountMin !== undefined && (
      <Badge status="info" className="gap-1">
        最小: {filters.amountMin}
        <button
          type="button"
          onClick={() => updateFilter("amountMin", undefined)}
          className="ml-1 hover:bg-destructive/20 rounded-full"
        >
          <X className="size-3" />
        </button>
      </Badge>
    )}
  </div>
)}
```

### 4. 篩選邏輯實現

#### 4.1 篩選函數標準
```typescript
const applyFilters = (newFilters: YourFilters) => {
  setFilters(newFilters);
  onFiltersChange?.(newFilters);

  let filteredData = [...data];

  // 搜尋篩選
  if (newFilters.search) {
    const searchTerm = newFilters.search.toLowerCase();
    filteredData = filteredData.filter((item) =>
      item.name.toLowerCase().includes(searchTerm) ||
      item.description?.toLowerCase().includes(searchTerm)
    );
  }

  // 類別篩選
  if (newFilters.category) {
    filteredData = filteredData.filter(
      (item) => item.category === newFilters.category
    );
  }

  // 日期範圍篩選
  if (newFilters.dateFrom) {
    const fromDate = new Date(newFilters.dateFrom);
    filteredData = filteredData.filter(
      (item) => new Date(item.date) >= fromDate
    );
  }
  if (newFilters.dateTo) {
    const toDate = new Date(newFilters.dateTo);
    toDate.setHours(23, 59, 59, 999); // 包含整天
    filteredData = filteredData.filter(
      (item) => new Date(item.date) <= toDate
    );
  }

  // 數字範圍篩選
  if (newFilters.amountMin !== undefined) {
    filteredData = filteredData.filter(
      (item) => item.amount >= newFilters.amountMin!
    );
  }
  if (newFilters.amountMax !== undefined) {
    filteredData = filteredData.filter(
      (item) => item.amount <= newFilters.amountMax!
    );
  }

  onFilterChange(filteredData);
};
```

#### 4.2 輔助函數
```typescript
const updateFilter = (key: keyof YourFilters, value: any) => {
  const newFilters = { ...filters, [key]: value };
  applyFilters(newFilters);
};

const clearFilters = () => {
  setFilters({});
  onFiltersChange?.({});
  onFilterChange(data);
};

const hasActiveFilters = Object.values(filters).some(
  (value) => value !== undefined && value !== null && value !== "" && value !== "all"
);
```

### 5. 主頁面整合

#### 5.1 頁面狀態管理
```typescript
const [allData, setAllData] = useState<YourRecord[]>([]);
const [filteredData, setFilteredData] = useState<YourRecord[]>([]);
const [currentFilters, setCurrentFilters] = useState<YourFiltersType>({});

const handleFilterChange = (newFilteredData: YourRecord[]) => {
  setFilteredData(newFilteredData);
};

const handleFiltersChange = (filters: YourFiltersType) => {
  setCurrentFilters(filters);
};
```

#### 5.2 篩選器組件使用
```typescript
{/* 篩選器組件 */}
<YourFilters
  data={allData}
  onFilterChange={handleFilterChange}
  onFiltersChange={handleFiltersChange}
/>

<DataTable
  columns={columns}
  data={filteredData}  // 使用篩選後的資料
  isLoading={isLoading}
  // 移除 DataTable 的內建搜尋功能
/>
```

### 6. 樣式規範

#### 6.1 必須使用的 CSS 類別
- **篩選器容器**: `space-y-4`
- **控制列**: `flex items-center justify-between`
- **篩選面板**: `grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 p-4 border rounded-lg bg-muted/20`
- **欄位容器**: `space-y-2`
- **標籤**: `text-sm font-medium`
- **圖標標籤**: `text-sm font-medium flex items-center gap-1`
- **標籤區域**: `flex flex-wrap gap-2`
- **Badge**: `status="info" className="gap-1"`
- **關閉按鈕**: `ml-1 hover:bg-destructive/20 rounded-full`

#### 6.2 響應式設計
- 使用 `grid-cols-1 md:grid-cols-2 lg:grid-cols-4` 確保在不同螢幕尺寸下的良好顯示
- 搜尋框使用 `w-64` 固定寬度
- 標籤使用 `flex-wrap` 自動換行

### 7. 圖標使用規範

#### 7.1 常用圖標對應
- **篩選器按鈕**: `<Filter className="size-4" />`
- **清除按鈕**: `<X className="size-4 mr-1" />`
- **日期欄位**: `<Calendar className="size-4" />`
- **金額欄位**: `<DollarSign className="size-4" />`
- **附件欄位**: `<Paperclip className="size-4" />`
- **標籤關閉**: `<X className="size-3" />`

### 8. 特殊欄位處理

#### 8.1 布林值篩選
```typescript
<Select
  value={
    filters.hasReceipt === null || filters.hasReceipt === undefined
      ? "all"
      : filters.hasReceipt.toString()
  }
  onValueChange={(value) => {
    if (value === "all") {
      updateFilter("hasReceipt", null);
    } else {
      updateFilter("hasReceipt", value === "true");
    }
  }}
>
  <SelectTrigger>
    <SelectValue placeholder="選擇狀態" />
  </SelectTrigger>
  <SelectContent>
    <SelectItem value="all">全部</SelectItem>
    <SelectItem value="true">是</SelectItem>
    <SelectItem value="false">否</SelectItem>
  </SelectContent>
</Select>
```

#### 8.2 動態選項生成
```typescript
// 從資料中提取唯一值
const uniqueCategories = Array.from(
  new Set(data.map((item) => item.category).filter(Boolean))
);

// 在 SelectContent 中使用
{uniqueCategories.map((category) => (
  <SelectItem key={category} value={category}>
    {category}
  </SelectItem>
))}
```

### 9. 檢查清單

實現篩選器組件時，確保：

1. ✅ 使用一致的 UI 佈局和樣式
2. ✅ 實現展開/收合功能
3. ✅ 顯示活躍篩選器數量
4. ✅ 提供清除篩選功能
5. ✅ 整合主要搜尋框
6. ✅ 使用正確的 Badge 組件和 status
7. ✅ 實現篩選器標籤顯示
8. ✅ 處理特殊欄位類型（日期、數字、布林值）
9. ✅ 從資料動態生成選項
10. ✅ 確保響應式設計
11. ✅ 使用適當的圖標
12. ✅ 在主頁面正確整合篩選器

這套篩選器標準確保了所有 CRUD 列表頁面都有一致的篩選體驗和視覺效果。

## 開發流程規則

### 構建和測試
- **不需要每次修改後都執行 `pnpm dev` 來確認結果**
- 只有在以下情況才需要執行構建命令：
  - 修復 TypeScript 類型錯誤時
  - 確認 API 路由或後端邏輯變更時
  - 部署前的最終驗證
  - 用戶明確要求測試構建時

### 代碼修改原則
- 專注於代碼邏輯的正確性和類型安全
- 使用 TypeScript 類型檢查來確保代碼質量
- 遵循現有的代碼風格和架構模式
- 優先考慮代碼的可讀性和維護性

### 錯誤處理
- 如果遇到構建錯誤，優先修復 TypeScript 類型問題
- 確保所有導入的組件和函數都存在
- 檢查接口定義是否完整
- 驗證 API 端點和數據結構的一致性

### 性能考慮
- 避免不必要的構建來節省開發時間
- 使用 TypeScript 編譯器來快速檢查語法錯誤
- 依賴 IDE 的實時錯誤檢查功能

## 項目特定規則

### 技術棧
- TypeScript + Next.js App Router
- Shadcn UI + Radix UI + Tailwind CSS
- Prisma + PostgreSQL
- Hono API 框架

### 代碼風格
- 使用函數式組件
- 優先使用 Server Components
- 遵循 Next.js 最佳實踐
- 使用 ESLint 和 Prettier 進行代碼格式化

### 文件組織
- 前端代碼放在 `apps/web` 目錄
- 後端邏輯放在 `packages` 目錄
- 使用模組化架構
- 保持清晰的目錄結構
